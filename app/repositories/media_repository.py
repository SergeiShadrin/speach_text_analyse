from sqlalchemy.orm import Session
from app.core.entities import MediaFile, Transcription, ProcessingStatus, MediaType, TranscriptionChunk
from typing import Optional, List, Dict, Any
import os
import uuid



class MediaRepository:


    def __init__(self, db: Session):
        """
        The repository needs an active Database Session to work.
        """
        self.db = db


    def create_text_only_entry(self, filename: str, full_text: str) -> MediaFile:
        """
        Creates a record for a transcription that has no source audio.
        Useful for importing existing notes or texts.
        """
        # 1. Create the 'Shell' MediaFile (Metadata holder)
        new_file = MediaFile(
            filename=filename,
            file_path=None,  # No file on disk!
            media_type=MediaType.AUDIO, # Default
            status=ProcessingStatus.COMPLETED # It's already done
        )
        self.db.add(new_file)
        self.db.commit()
        self.db.refresh(new_file)


        # 2. Attach the Text
        transcription = Transcription(
            media_file_id=new_file.id,
            full_text=full_text,
            model_used="manual_import"
        )
        self.db.add(transcription)
        self.db.commit()
        
        return new_file


    def create_media_file(self, filename: str, path: str, media_type: MediaType) -> MediaFile:
        """Creates a new record for a file being uploaded."""
        new_file = MediaFile(
            filename=filename,
            file_path=path,
            media_type=media_type, # Logic to detect type can go here
            status=ProcessingStatus.PENDING
        )
        self.db.add(new_file)
        self.db.commit()
        self.db.refresh(new_file) # Reloads with the new ID generated by DB
        return new_file


    def mark_as_processing(self, file_id: uuid.UUID):
        """Updates status to PROCESSING."""
        file = self.db.query(MediaFile).filter(MediaFile.id == file_id).first()
        if file:
            file.status = ProcessingStatus.PROCESSING
            self.db.commit()



    def init_transcription(self, media_file_id: uuid.UUID, model: str) -> Transcription:
        """
        Creates an empty transcription record so we have an ID 
        to attach chunks to while processing.
        """
        new_transcription = Transcription(
            media_file_id=media_file_id,
            full_text="",  # Empty for now
            model_used=model,
            language="detecting..." 
        )
        self.db.add(new_transcription)
        self.db.commit()
        self.db.refresh(new_transcription)
        return new_transcription



    def save_chunks(self, transcription_id: uuid.UUID, chunks_data: List[Dict[str, Any]]):
        """
        Bulk saves text chunks.
        """
        chunk_objects = []
        for data in chunks_data:
            chunk = TranscriptionChunk(
                transcription_id=transcription_id,
                chunk_index=data['index'],
                text_content=data['text'],  # <--- WAS MISSING IN YOUR CODE
                embedding=data.get('vector', None) # Use None, not "None"
            )
            chunk_objects.append(chunk)

        try:
            self.db.add_all(chunk_objects)
            self.db.commit()
        except Exception as e:
            self.db.rollback()
            raise e
    

    def create_chunk(self, transcription_id: uuid.UUID, index: int, text: str):
        """
        Replaces: open("chunk_001.txt", "w").write(...)
        """
        chunk = TranscriptionChunk(
            transcription_id=transcription_id,
            chunk_index=index,
            text_content=text,
            embedding=None # We will calculate vectors later
        )
        self.db.add(chunk)
        self.db.commit()



    def get_all_chunks_text(self, transcription_id: uuid.UUID) -> List[str]:
        """
        Replaces: reading files from 'chunks_text_dir'
        Returns the text parts in the correct order (0, 1, 2...).
        """
        chunks = (
            self.db.query(TranscriptionChunk)
            .filter(TranscriptionChunk.transcription_id == transcription_id)
            .order_by(TranscriptionChunk.chunk_index) # CRITICAL: Maintain order!
            .all()
        )
        return [c.text_content for c in chunks]

        
    def delete_all_chunks(self, transcription_id: uuid.UUID):
        """
        Removes all chunks for a specific transcription. 
        Used before re-populating with the final, clean text.
        """
        # 1. Delete Query
        self.db.query(TranscriptionChunk).filter(
            TranscriptionChunk.transcription_id == transcription_id
        ).delete()
        
        # 2. Commit changes
        self.db.commit()
        print(f"ðŸ§¹ Cleared old chunks for ID: {transcription_id}")



    def update_transcription_full_text(self, transcription_id: uuid.UUID, text: str):
        """
        Updates the full text of an EXISTING transcription record.
        """
        record = self.db.query(Transcription).filter(Transcription.id == transcription_id).first()
        if record:
            record.full_text = text
            # Ensure status is COMPLETED on the PARENT file
            if record.media_file:
                record.media_file.status = ProcessingStatus.COMPLETED
            self.db.commit()



    def archive_storage(self, file_id: uuid.UUID):
        """
        Deletes the physical .mp4/.wav file to save space, 
        but KEEPS the database record and transcription.
        """
        # 1. Get the record
        record = self.db.query(MediaFile).filter(MediaFile.id == file_id).first()
        
        if not record:
            return None

        # 2. Delete the actual file from Disk (if it exists)
        if record.file_path and os.path.exists(record.file_path):
            try:
                os.remove(record.file_path)
                print(f"ðŸ—‘ï¸ Deleted heavy file: {record.file_path}")
            except OSError as e:
                print(f"âš ï¸ Error deleting file: {e}")

        # 3. Update Database to reflect this
        record.file_path = None       # Clear the path
        record.status = ProcessingStatus.ARCHIVED # Mark as Archived
        
        self.db.commit()
        return record



    # --- HELPER: Find Transcriptions (even if file is deleted) ---
    def get_transcription_by_id(self, file_id: uuid.UUID) -> Optional[str]:
        """
        Finds text regardless of whether the video still exists.
        """
        # We query the MediaFile, knowing the transcription is linked
        record = self.db.query(MediaFile).filter(MediaFile.id == file_id).first()
        
        if record and record.transcription:
            return record.transcription.full_text
        return None
    

    def search_by_filename(self, query_string: str) -> List[Dict]:
        """
        Finds all files whose name contains the query_string.
        Example: query="meet" -> finds "Meeting.mp4" and "team_meeting_final.wav"
        """
        # 1. Perform the search
        # .ilike() is a PostgreSQL feature for "Case-Insensitive Like"
        # The % symbols mean "match anything before or after"
        results = self.db.query(MediaFile).filter(
            MediaFile.filename.ilike(f"%{query_string}%")
        ).all()

        # 2. Return a clean list of results
        found_files = []
        for file in results:
            found_files.append({
                "id": str(file.id),          # Convert UUID to string for easy reading
                "filename": file.filename,
                "status": file.status.value,
                "has_text": True if file.transcription else False
            })
            
        return found_files