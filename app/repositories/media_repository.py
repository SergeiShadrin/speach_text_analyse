from sqlalchemy.orm import Session
from app.core.entities import Project, MediaFile, Transcription, ProcessingStatus, MediaType, TranscriptionChunk
from typing import Optional, List, Dict, Any, Union
import os
import uuid
from datetime import date



class MediaRepository:


    def __init__(self, db: Session):
        """
        The repository needs an active Database Session to work.
        """
        self.db = db

    def _get_default_project_id(self) -> uuid.UUID:
        """
        Internal helper: Finds the 'Global Default' project.
        If it doesn't exist, it creates it instantly.
        """
        DEFAULT_NAME = "Transcriptions" 

        # 1. Try to find the default project
        project = self.db.query(Project).filter(Project.name == DEFAULT_NAME).first()
        
        # 2. If it exists, return its ID
        if project:
            return project.id
            
        # 3. If not, create it once and return the new ID
        try:
            new_project = Project(name=DEFAULT_NAME)
            self.db.add(new_project)
            self.db.commit()
            self.db.refresh(new_project)
            return new_project.id
        except Exception:
            # If creation failed (because another process just created it), rollback and fetch again
            self.db.rollback()
            project = self.db.query(Project).filter(Project.name == DEFAULT_NAME).first()
            return project.id
        

    def get_or_create_project(self, project_name: str) -> Project:
        """
        Retrieves a project by name, or creates it if it doesn't exist.
        """
        # 1. Try to find it
        project = self.db.query(Project).filter(Project.name == project_name).first()
        if project:
            return project
            
        # 2. Create if missing (with safety)
        try:
            new_project = Project(name=project_name)
            self.db.add(new_project)
            self.db.commit()
            self.db.refresh(new_project)
            return new_project
        except Exception:
            self.db.rollback()
            return self.db.query(Project).filter(Project.name == project_name).first()


    def create_text_only_entry(self, 
                               filename: str, 
                               full_text: str, 
                               description: str,
                               event: str = None,
                               event_date: Optional[date] = None, 
                               project_id: uuid.UUID = None) -> MediaFile:
        """
        Creates a record for a transcription that has no source audio.
        Useful for importing existing notes or texts.
        """
        if project_id is None:
            project_id = self._get_default_project_id()

        # 1. Create the 'Shell' MediaFile (Metadata holder)
        new_file = MediaFile(
            filename=filename,
            file_path=None, 
            description=description,
            media_type=MediaType.AUDIO, 
            status=ProcessingStatus.COMPLETED,
            event=event,
            event_date=event_date, 
            project_id=project_id
        )
        self.db.add(new_file)
        self.db.commit()
        self.db.refresh(new_file)

        # 2. Attach the Text
        transcription = Transcription(
            media_file_id=new_file.id,
            full_text=full_text,
            model_used="manual_import"
        )
        self.db.add(transcription)
        self.db.commit()

        transcription_id = new_file.transcription.id
        
        return transcription_id
    


    def create_media_file(self, 
                          filename: str, 
                          path: str, 
                          description: str,
                          media_type: MediaType, 
                          event: str = None,
                          event_date: Optional[date] = None, 
                          project_id: uuid.UUID = None) -> MediaFile:
        """Creates a new record for a file being uploaded."""
        
        if project_id is None:
            project_id = self._get_default_project_id()

        new_file = MediaFile(
            filename=filename,
            file_path=path,
            media_type=media_type, 
            description=description,
            status=ProcessingStatus.PENDING,
            project_id=project_id,
            # ‚úÖ 2. Map the new fields to the DB object
            event=event,
            event_date=event_date
        )
        
        self.db.add(new_file)
        self.db.commit()
        self.db.refresh(new_file) # Reloads with the new ID generated by DB
        return new_file


    def mark_as_processing(self, file_id: uuid.UUID):
        """Updates status to PROCESSING."""
        file = self.db.query(MediaFile).filter(MediaFile.id == file_id).first()
        if file:
            file.status = ProcessingStatus.PROCESSING
            self.db.commit()



    def init_transcription(self, media_file_id: uuid.UUID, model: str) -> Transcription:
        """
        Creates an empty transcription record so we have an ID 
        to attach chunks to while processing.
        """
        new_transcription = Transcription(
            media_file_id=media_file_id,
            full_text="",  # Empty for now
            model_used=model,
            language="..." 
        )
        self.db.add(new_transcription)
        self.db.commit()
        self.db.refresh(new_transcription)
        return new_transcription



    def save_chunks(self, transcription_id: uuid.UUID, chunks_data: List[Dict[str, Any]]):
        """
        Bulk saves text chunks.
        """
        chunk_objects = []
        for data in chunks_data:
            chunk = TranscriptionChunk(
                transcription_id=transcription_id,
                chunk_index=data['index'],
                text_content=data['text'],  # <--- WAS MISSING IN YOUR CODE
                embedding=data.get('vector', None) # Use None, not "None"
            )
            chunk_objects.append(chunk)

        try:
            self.db.add_all(chunk_objects)
            self.db.commit()
        except Exception as e:
            self.db.rollback()
            raise e
    

    def create_chunk(self, transcription_id: uuid.UUID, index: int, text: str):
        """
        Replaces: open("chunk_001.txt", "w").write(...)
        """
        chunk = TranscriptionChunk(
            transcription_id=transcription_id,
            chunk_index=index,
            text_content=text,
            embedding=None # We will calculate vectors later
        )
        self.db.add(chunk)
        self.db.commit()



    def get_all_chunks_text(self, transcription_id: uuid.UUID) -> List[str]:
        """
        Replaces: reading files from 'chunks_text_dir'
        Returns the text parts in the correct order (0, 1, 2...).
        """
        chunks = (
            self.db.query(TranscriptionChunk)
            .filter(TranscriptionChunk.transcription_id == transcription_id)
            .order_by(TranscriptionChunk.chunk_index) # CRITICAL: Maintain order!
            .all()
        )
        return [c.text_content for c in chunks]

        
    def delete_all_chunks(self, transcription_id: uuid.UUID):
        """
        Removes all chunks for a specific transcription. 
        Used before re-populating with the final, clean text.
        """
        # 1. Delete Query
        self.db.query(TranscriptionChunk).filter(
            TranscriptionChunk.transcription_id == transcription_id
        ).delete()
        
        # 2. Commit changes
        self.db.commit()
        print(f"üßπ Cleared old chunks for ID: {transcription_id}")



    def update_transcription_full_text(self, transcription_id: uuid.UUID, text: str):
        """
        Updates the full text of an EXISTING transcription record.
        """
        record = self.db.query(Transcription).filter(Transcription.id == transcription_id).first()
        if record:
            record.full_text = text
            # Ensure status is COMPLETED on the PARENT file
            if record.media_file:
                record.media_file.status = ProcessingStatus.COMPLETED
            self.db.commit()



    def archive_storage(self, file_id: uuid.UUID):
        """
        Deletes the physical .mp4/.wav file to save space, 
        but KEEPS the database record and transcription.
        """
        # 1. Get the record
        record = self.db.query(MediaFile).filter(MediaFile.id == file_id).first()
        
        if not record:
            return None

        # 2. Delete the actual file from Disk (if it exists)
        if record.file_path and os.path.exists(record.file_path):
            try:
                os.remove(record.file_path)
                print(f"üóëÔ∏è Deleted heavy file: {record.file_path}")
            except OSError as e:
                print(f"‚ö†Ô∏è Error deleting file: {e}")

        # 3. Update Database to reflect this
        record.file_path = None       # Clear the path
        record.status = ProcessingStatus.ARCHIVED # Mark as Archived
        
        self.db.commit()
        return record
    

